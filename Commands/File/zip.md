# zip
## 1. 名称
`zip` - 打包和压缩文件集

## 2. 语法
`zip [-aABcdDeEfFghjklLmoqrRSTuvVwXyz!@$] [--longoption ...]  [-b path] [-n suffixes] [-t date] [-tt date] [zipfile [file ...]]  [-xi list]`  
   
`zipcloak` (详情见[zipcload](zipcloak.md))  
   
`zipnote` (详情见[zipnote](zipnote.md))  
   
`zipsplit` (详情见[zipsplit](zipsplit.md))  
   
## 3. 描述
`zip`是一个用于打包和压缩文件的工具. 支持所有常见的操作系统. 它和Unix的`[tar](tar.md), compress`命令有这类色的功能, 并且与`PKZIP`(MSDOS系统使用)兼容.  
  
`zip`与`[unzip](unzip.md)`是一个组合, 分别用于压缩和解压缩. 这两个命令也可以作用于使用`PKZIP`压缩成的文件上, 相同的`PKZIP`和`PKUNZIP`也可以对`zip`压缩的文件进行操作. 另外如果安装了`bzip2`相关的库的话, `zip`可以支持`bzip2`格式的压缩.  
  
可以在[示例](#示例)部分查看常见的zip使用方式.  
  
**关于大型文件和`Zip64`**. 对于将超过4GB的文件添加进压缩包时, 或者压缩包中存在使用`Zip64`打包的项目, 或者压缩包的大小超过了4GB时, 或者需要压缩的文件数量超过了64K, `zip`会自动使用`Zip64`扩展程序进行压缩. 另外对于通过标准输入流传输的文件进行压缩时, 也会自动使用`Zip64`. 因为无法提前的值标准输入流传输来的文件大小. 但是可以使用`-fz-`选项强制要求`zip`使用`PKZIP`对文件进行压缩.  
   
如果想要获得`zip`或者`unzip`的简要帮助说明, 可以直接通过在命令行上执行这两个命令并且不带任何的参数.

## 4. 使用
该命令在压缩文件集来节省磁盘空间时非常有用.  
  
`zip`命令也可以将一个或者多个压缩文件打包到一个`zip`文件中, 并保留着这些文件的相关信息(名称, 路径, 数据, 上次的修改时间, 安全信息和用于校验完整性的信息). 可以通过一个命令将一个完整的目录打包到`zip`文件中.  
  
### **命令的格式**. 
基本的命令格式为:  
  
&#8195;`zip 选项 zip文件名 需要打包的文件1 文件2 ...`  
  
其中`zip文件名`是一个新的或者已存在的zip文件, `需要打包的文件`可以是一个目录或者一个文件. 当`zip文件名`是一个已存在的zip文件, 并且`需要打包的文件`已存在于这个文件中(拥有相同的路径), `zip`将会替换原有的文件.   
  
例如`foo.zip`中已包含了文件`foo/file1`和`foo/file2`, 并且目录`foo`中包含文件`foo/file1`和`foo/file3`, 那么:  
  
&#8195;`zip -r foo.zip foo`  
  
或者更加简短的写法:  
  
&#8195;`zip -r foo foo`  
  
将会替换`foo.zip`中的`foo/file1`并且将`foo/file3`添加进`foo.zip`中. 在操作完成后, `foo.zip`中会包含`foo/file1`, `foo/file2`和`foo/file3`, 其中的`foo/file2`和之前的没有任何变化.  
  
所以在`zip`命令执行之前, `foo.zip`文件中包括:  
  
&#8195;`foo/file1  foo/file2`  
  
另外`foo`文件夹中有:  
  
&#8195;`file1  file3`  
  
在执行完`zip`操作后, `foo.zip`中:   
  
&#8195;`foo/file1  foo/file2  foo/file3`  
  
其中`foo/file1`是被替换的, `foo/file3`是新添加的.  
  
### **`-@ 文件集`.** 
如果一个文件集跟在**`-@ [MacOS上不适用]`**后面, `zip`将会通过标准输入流去获取这些文件而不是通过命令行. 例如:  
  
&#8195;`zip -@ foo`  
  
将会这些列在标准输入流中的文件保存到`foo.zip`中.  
  
在`Unix`系统下, 可以使用这个选项配合着[`find`](../find.md)命令实现非常强大的功能. 例如: 将当前目录和子路径下所有的`C`源代码打包可以通过:  
  
&#8195;`find . -name "*.[ch]" -print | zip source -@`  
  
(注意: 这里的正则表达式必须使用引号以确保shell可以正常的识别他们.)  
  
### **输入输出流.** 
`zip`可以接受一个`- (代表着标准输入输出)`作为`zip文件名称`, 在这种情况下`zip`将会把打包好的文件输出到标准输出流上去, 这样可以使用输出的文件通过管道被传送给其他的程序. 例如:  
  
&#8195;`zip -r - . | dd of=/dev/nrst0 obs=16k`  
  
将会把zip打包的文件通过管道直接备份到一个指定了固定区块大小的磁盘中去.  
  
`zip`也可以接受一个`- (代表着标准输入输出)`作为`需要打包的文件名称`, 这种情况下`zip`可以从标准输入流中获取需要打包的文件, 这些文件一般都是其他的程序通过管道输入给`zip`的. 例如:  
  
&#8195;`tar cf - . | zip backup -`  
  
将会压缩`tar`命令传输来的当前路径下的所有文件. 这种压缩方式一般情况下会好于上一个例子中通过`-r`选项的压缩方式. 因为这样`zip`可以利用文件之间的冗余达到更好的压缩效果. 可以使用下面的命令对上面压缩的文件进行解压:  
  
&#8195;`unzip -p backup | tar xf -`  
  
当没有指定`zip文件名称`并且标准输出没有终结时(后续还有程序可以处理`zip`的输出), `zip`将被用作一个过滤器, 对标准输入的数据进行压缩后返回给标准输出. 例如:  
  
&#8195;`tar cf - . | zip | dd of=/dev/nrst0 obs=16k`  
  
等同于  
  
&#8195;`tar cf - . | zip - - | dd of=/dev/nrst0 obs=16k`  
  
通过上面的方式压缩的zip文件可以使用`funzip (由unzip包提供)`进行解压, 或者使用`gunzip (由gzip包提供)`解压. (但是当`zip`使用`Zip64`格式压缩成的文件是无法通过`gunzip`进行解压的). 例如:  
  
&#8195;`dd if=/dev/nrst0 ibs=16k | funzip | tar xvf -`  
  
这个文件流(dd的of)也可以保存成一个文件, 然后通过`unzip`去解压.  
  
### **zip文件**
当要改变一个已存在的zip文件时, `zip`会重新创建一个新的临时文件将数据写入这个文件中, 只有当程序正确执行完成后才会使用新的临时文件替换原有的zip文件.  
  
如果zip文件的结尾没有包含扩展名, 则会自动为文件添加`.zip`扩展名. 如果文件已经包含一个非`.zip`的扩展名, 那么原扩展名将不会被修改. 但是对于切割过的zip文件要求最后一个部分的扩展名必须是`.zip`.  
  
### **扫描和读取文件**
当`zip`程序启动时会去扫描那些需要被打包的文件. 如果此次扫描的时长超过5秒, `zip`会展示"正在扫描文件"的提示信息, 并且每隔2秒或者扫描了指定数量的文件后会展示一个程序执行中的`.`符号. 如果在两个`.`出现之间的时间超过了2秒可能是因为查找每个文件比较耗时或者网络连接不稳定. **`-ds`** 无法控制扫描文件的`.`的速度, 但是可以使用**`-q`**禁止`.`的显示. **`-sf`**显示文件的选项可以被用来显示已经扫描完成的文件.  
  
如果`zip`无法读取一个文件, 将会提示一个警告信息并继续执行. 查看下面**`-MM`**选项的介绍来了解更多关于`zip`如何处理那些没有匹配到的正则表达式和无法读取的文件. 如果有文件被跳过了, `zip`会在执行完成后显示一条警告消息标注多少文件被读取, 多少文件被跳过.  
  
### **命令模式**
`zip`目前已支持两种类型的命令模式: **内部模式**和**外部模式**. 其中**外部模式**(增加, 更新和刷新)可以从文件系统中读取文件, 而**内部模式**(删除和复制)只会对zip文件内部进行操作.  
  
* **add**
  - 更新已存在的文件和添加新的文件. 如果zip文件不存在会自动创建, 这是默认的模式.
* **update** (**-u**)
  - 更新已存在的文件和添加新的文件. 如果zip文件不存在则提示警告消息并创建文件.
* **freshen** (**-f**)
  - 如果文件系统中的文件更新, 则更新已存在的文件. 这个模式不会添加新的文件到zip文件中.
* **delete** (**-d**)
  - 获取zip文件中的文件并删除他们.
* **copy** (**-U**)
  - 获取一个zip文件中的文件并将他们复制到另一个新的zip文件中. 这个新的模式和**`update`**模式很相似, 但这个模式是从一个已存在的zip文件中获取文件而不是从文件系统中获取. 它使用**`--out`**选项将获取到的文件写入新的zip文件中并不会修改原来的zip文件.
  
新的文件同步选项**`-FS`**也可以被认为是一个新的模式, 和**`update`**类似. 这个模式对已存在于zip文件中的文件和文件系统中的文件进行比较, 如果文件时间和大小有不同的话, 会更新这个文件. 另外也可以新增不存在的文件, 删除已存在的文件.  
  
### **切分zip文件**
3.0及以上版本的`zip`程序支持创建拆分文件. 一个切分的zip文件是由一个标准的zip文件切分成多份而成的.  
  
切分文件的一个常用场景是将一个大的zip文件切分成多个小块, 并保存在多个移动设备中. 对于一个zip文件, 如果要把它拆分成20份, 那么这些文件的命名将会是`ARCHIVE.z01, ARCHIVE.z02, ..., ARCHIVE.z19, ARCHIVE.zip`(将ARCHIVE替换为zip文件的名称即可). 注意最后一个zip子文件的扩展名为`.zip`.  
  
使用**`-s`**选项去设置切分文件的大小并创建一个拆分的zip文件. 切分文件的大小需要以一个数字和一个单位组成, 单位包括: k(KB), m(MB), g(GB), 或者t(TB), 其中默认为m. **`-sp`**可以实现暂停`zip`程序并更换可移动设备. 具体的描述和警告消息和查看**`-s`**和**`-sp`**选项的内容.  
  
虽然`zip`不支持对拆分后文件内容的更新, 但是`zip`提供**`-O (--output-file or --out)`**选项允许对已拆分的文件更新并保存到一个新的zip文件中.  
  
&#8195;`zip inarchive.zip foo.c bar.c --out outarchive.zip`  
  
首先会读取`inarchive.zip`文件的内容, 即使它是已拆分的zip文件, 然后将`foo.c`和`bar.c`添加到结果zip文件(`outarchive.zip`)中. 如果`inarchive.zip`是一个已拆分的文件那么`outarchive.zip`默认情况下会使用相同的切分文件大小. 需要注意的是: 如果`outarchive.zip`或者其他需要被创建的拆分文件已存在的话, 将会对这些文件自动进行重写并不发出警告消息.  
  
### **命令行格式**
当前版本的`zip`已经更新了命令行程序并且支持长选项.  
  
短选项的格式如下:  
  
&#8195;`-s[-][s[-]...][value][=value][ value]`  
  
其中, `s`是指有一到两个字符的短选项. 一个带值的短选项会被放在参数的最后面, 这个选项后面的任何东西都会被视为这个选项的值. 如果这个选项可以被否定(执行相反的效果)那么在这个选项后面紧跟着的"-"可以对选项进行否定. 短选项可以被作为独立的参数给出:  
  
&#8195;`-s[-][value][=value][ value] -s[-][value][=value][ value] ...`  
  
一般情况下, 短选项可以将自己的值作为参数的一部分或者作为一个独立的参数. 并且短选项也支持"=", 所以  
  
&#8195;`-ttmmddyyyy`  
  
和  
  
&#8195;`-tt=mmddyyyy`  
  
和  
  
&#8195;`-tt mmddyyyy`  
  
都可以达到相同的效果. 但是**`-x`**和**`-i`**选项支持接收多个值的集合, 它们的使用方法和上面的有些不同, 详细的使用方法可以参照对**`-x`**和**`-i`**选项的介绍.  
  
长选项的格式为:  
  
&#8195;`--longoption[-][=value][ value]`  
  
其中, 长选项以--开头, 并且长选项的名称包含多个字符, 它可以在结尾跟一个"-"表示对选项的否定(如果选项支持否定的话), 并且如果选项需要参数的话可以通过在选项后面跟=的方式实现, 也可以通过将值作为另外一个参数的方式实现. 所以  
  
&#8195;`--before-date=mmddyyyy`  
  
和  
  
&#8195;`--before-date mmddyyyy`  
  
具有相同的效果.  
  
## 5. 选项
* -a, --ascii
  - 将文件转为ASCII编码格式
* -B, --binary
  - 将文件强制转为可读的二进制文件, 默认情况下文件是文本文件格式.
* -b path, --temp-path path
  - 为临时创建的zip文件指定一个路径`path`. 例如:
    - `zip -b /tmp stuff *`
  - 将会把临时创建的zip文件放在`/tmp`路径下, 并且在操作完成后将`stuff.zip`复制到当前目录下. 当需要更新一个已存在的zip文件并且保存旧的zip文件的文件系统没有足够的空间可以同时保存新的和旧的zip文件时这个选项很有用. 需要注意的是使用这个选项会需要额外的时间使得zip可以将新打包的zip文件复制到目标文件系统下.
* -c, --entry-comments
  - 为每个文件添加一行备注信息. 当文件操作(添加, 更新)完成后, 用户可以为每个文件添加备注信息. 使用回车键提交写入的备注信息即可.
* -d, --delete
  - 从zip文件中移除内容, 例如:
    - `zip -d foo foo/tom/junk foo/harry/\* \*.o`
  - 将会移除`foo/tom/junk`, 所以以`foo/harry/`开头的文件, 和所有以**`.o`**(任何路径下)结尾的文件. 注意: 反斜杠`\`可以禁止zip继续向下扩展路径, 这样zip才可以识别星号`*`. 这使得zip可以去匹配zip文件中的内容而不是当前路径下的内容. 但是反斜杠`\`在MSDOS内核的系统下是不适用的, 我们可以使用引号来实现同样的效果.
    - `zip -d foo foo/tom/junk "foo/harry/*" "*.o"`
  - 如果不对星号`*`进行转义, 根据shell的扩展规则将会把星号`*`转为当前路径下的所有文件的集合, 之后zip会根据这个集合的文件名称去删除zip文件中的文件.
  - **注意**: 在MSDOS系统下, 当在匹配zip文件中的名称时, **`-d`**是大小写敏感的. 如果zip文件是在MSDOS系统上使用`PKZIP`打包的话, 需要我们输入的待删除的文件是大写的格式. 但是使用新的选线**`-ic`**可以忽略大小写问题.
* -db, --display-bytes
  - 展示多少字节被压缩, 多少字节被保留.
* -dc, --display-counts
  - 展示多少文件被压缩, 多少文件被跳过.
* -dd, --display-dots
  - 在每个文件被压缩时展示一个点`.`符号. 在下面的**`-ds`**选项中设置点的大小. 默认情况下每10MB的输入内容被处理后会输出一个点. **`-v`**也会展示点并且速度也是通过**`-ds`**去控制的.
* -dg, display-globaldots

使用zip格式的文件压缩
格式:zip 选项 压缩包名 需要压缩的文集序列

#常用选项
-m		#压缩完成有删除源文件
-r		#需要压缩的是一个目录
-j		#忽略子目录内容
-n 文件		#选择不需要压缩的文件(忽略他们)
-y		#不要压缩链接文件的源文件
-数字		#设置压缩率(1-9,9为最高压缩率)

#注意
1.zip与gz的区别
zip在处理文本文件处理方面优越
gz在处理二进制文件处理方面优越
2.-n选项的后面如果有多种格式,将每种格式之间使用:分隔

#示例
#zip后面接压缩后的文件名，在它后面输入要压缩的文件
zip file.zip *			
zip file.zip aaa bbb ccc	#将多个文件压缩到同一包中
#将a.txt压缩为file.zip文件并在压缩完成后删除源文件
zip -m file.zip a.txt
zip -r file.zip *		#将当前目录下的子目录一起压缩
zip -j file.zip *		#忽略子目录的内容
zip -n .jpg: .gif:.mpg		#将以压缩的文件或者没必要压缩的文件去掉
zip -y file.zip *		#不要压缩链接文件的原文件
zip -3 file.zip *		#按照3的压缩率压缩指定文件


-------------------------------------------------------------------
#解压缩文件夹
格式:unzip 压缩包

#常用选项
-Z		#显示压缩包内容
-l		#同上
-v		#同上

#示例
unzip file.zip			#解压目标文件
unzip -Z file.zip
unzip -l file.zip
unzip -v file.zip
