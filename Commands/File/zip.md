# zip

## 1. 名称

`zip` - 打包和压缩文件集

## 2. 语法

`zip [-aABcdDeEfFghjklLmoqrRSTuvVwXyz!@$] [--longoption ...] [-b path] [-n suffixes] [-t date] [-tt date] [zipfile [file ...]] [-xi list]`

`zipcloak` (详情见[zipcload](zipcloak.md))

`zipnote` (详情见[zipnote](broken-reference))

`zipsplit` (详情见[zipsplit](zipnote.md))

## 3. 描述

`zip`是一个用于打包和压缩文件的工具. 支持所有常见的操作系统. 它和Unix的`[tar](tar.md), compress`命令有这类色的功能, 并且与`PKZIP`(MSDOS系统使用)兼容.

`zip`与`[unzip](unzip.md)`是一个组合, 分别用于压缩和解压缩. 这两个命令也可以作用于使用`PKZIP`压缩成的文件上, 相同的`PKZIP`和`PKUNZIP`也可以对`zip`压缩的文件进行操作. 另外如果安装了`bzip2`相关的库的话, `zip`可以支持`bzip2`格式的压缩.

可以在[示例](zip.md#示例)部分查看常见的zip使用方式.

**关于大型文件和`Zip64`**. 对于将超过4GB的文件添加进压缩包时, 或者压缩包中存在使用`Zip64`打包的项目, 或者压缩包的大小超过了4GB时, 或者需要压缩的文件数量超过了64K, `zip`会自动使用`Zip64`扩展程序进行压缩. 另外对于通过标准输入流传输的文件进行压缩时, 也会自动使用`Zip64`. 因为无法提前的值标准输入流传输来的文件大小. 但是可以使用`-fz-`选项强制要求`zip`使用`PKZIP`对文件进行压缩.

如果想要获得`zip`或者`unzip`的简要帮助说明, 可以直接通过在命令行上执行这两个命令并且不带任何的参数.

## 4. 使用

该命令在压缩文件集来节省磁盘空间时非常有用.

`zip`命令也可以将一个或者多个压缩文件打包到一个`zip`文件中, 并保留着这些文件的相关信息(名称, 路径, 数据, 上次的修改时间, 安全信息和用于校验完整性的信息). 可以通过一个命令将一个完整的目录打包到`zip`文件中.

### **命令的格式**.

基本的命令格式为:

 `zip 选项 zip文件名 需要打包的文件1 文件2 ...`

其中`zip文件名`是一个新的或者已存在的zip文件, `需要打包的文件`可以是一个目录或者一个文件. 当`zip文件名`是一个已存在的zip文件, 并且`需要打包的文件`已存在于这个文件中(拥有相同的路径), `zip`将会替换原有的文件.

例如`foo.zip`中已包含了文件`foo/file1`和`foo/file2`, 并且目录`foo`中包含文件`foo/file1`和`foo/file3`, 那么:

 `zip -r foo.zip foo`

或者更加简短的写法:

 `zip -r foo foo`

将会替换`foo.zip`中的`foo/file1`并且将`foo/file3`添加进`foo.zip`中. 在操作完成后, `foo.zip`中会包含`foo/file1`, `foo/file2`和`foo/file3`, 其中的`foo/file2`和之前的没有任何变化.

所以在`zip`命令执行之前, `foo.zip`文件中包括:

 `foo/file1 foo/file2`

另外`foo`文件夹中有:

 `file1 file3`

在执行完`zip`操作后, `foo.zip`中:

 `foo/file1 foo/file2 foo/file3`

其中`foo/file1`是被替换的, `foo/file3`是新添加的.

### **`-@ 文件集`.**

如果一个文件集跟在\*\*`-@ [MacOS上不适用]`\*\*后面, `zip`将会通过标准输入流去获取这些文件而不是通过命令行. 例如:

 `zip -@ foo`

将会这些列在标准输入流中的文件保存到`foo.zip`中.

在`Unix`系统下, 可以使用这个选项配合着[`find`](../find.md)命令实现非常强大的功能. 例如: 将当前目录和子路径下所有的`C`源代码打包可以通过:

 `find . -name "*.[ch]" -print | zip source -@`

(注意: 这里的正则表达式必须使用引号以确保shell可以正常的识别他们.)

### **输入输出流.**

`zip`可以接受一个`- (代表着标准输入输出)`作为`zip文件名称`, 在这种情况下`zip`将会把打包好的文件输出到标准输出流上去, 这样可以使用输出的文件通过管道被传送给其他的程序. 例如:

 `zip -r - . | dd of=/dev/nrst0 obs=16k`

将会把zip打包的文件通过管道直接备份到一个指定了固定区块大小的磁盘中去.

`zip`也可以接受一个`- (代表着标准输入输出)`作为`需要打包的文件名称`, 这种情况下`zip`可以从标准输入流中获取需要打包的文件, 这些文件一般都是其他的程序通过管道输入给`zip`的. 例如:

 `tar cf - . | zip backup -`

将会压缩`tar`命令传输来的当前路径下的所有文件. 这种压缩方式一般情况下会好于上一个例子中通过`-r`选项的压缩方式. 因为这样`zip`可以利用文件之间的冗余达到更好的压缩效果. 可以使用下面的命令对上面压缩的文件进行解压:

 `unzip -p backup | tar xf -`

当没有指定`zip文件名称`并且标准输出没有终结时(后续还有程序可以处理`zip`的输出), `zip`将被用作一个过滤器, 对标准输入的数据进行压缩后返回给标准输出. 例如:

 `tar cf - . | zip | dd of=/dev/nrst0 obs=16k`

等同于

 `tar cf - . | zip - - | dd of=/dev/nrst0 obs=16k`

通过上面的方式压缩的zip文件可以使用`funzip (由unzip包提供)`进行解压, 或者使用`gunzip (由gzip包提供)`解压. (但是当`zip`使用`Zip64`格式压缩成的文件是无法通过`gunzip`进行解压的). 例如:

 `dd if=/dev/nrst0 ibs=16k | funzip | tar xvf -`

这个文件流(dd的of)也可以保存成一个文件, 然后通过`unzip`去解压.

### **zip文件**

当要改变一个已存在的zip文件时, `zip`会重新创建一个新的临时文件将数据写入这个文件中, 只有当程序正确执行完成后才会使用新的临时文件替换原有的zip文件.

如果zip文件的结尾没有包含扩展名, 则会自动为文件添加`.zip`扩展名. 如果文件已经包含一个非`.zip`的扩展名, 那么原扩展名将不会被修改. 但是对于切割过的zip文件要求最后一个部分的扩展名必须是`.zip`.

### **扫描和读取文件**

当`zip`程序启动时会去扫描那些需要被打包的文件. 如果此次扫描的时长超过5秒, `zip`会展示"正在扫描文件"的提示信息, 并且每隔2秒或者扫描了指定数量的文件后会展示一个程序执行中的`.`符号. 如果在两个`.`出现之间的时间超过了2秒可能是因为查找每个文件比较耗时或者网络连接不稳定. **`-ds`** 无法控制扫描文件的`.`的速度, 但是可以使用\*\*`-q`\*\*禁止`.`的显示. \*\*`-sf`\*\*显示文件的选项可以被用来显示已经扫描完成的文件.

如果`zip`无法读取一个文件, 将会提示一个警告信息并继续执行. 查看下面\*\*`-MM`\*\*选项的介绍来了解更多关于`zip`如何处理那些没有匹配到的正则表达式和无法读取的文件. 如果有文件被跳过了, `zip`会在执行完成后显示一条警告消息标注多少文件被读取, 多少文件被跳过.

### **命令模式**

`zip`目前已支持两种类型的命令模式: **内部模式**和**外部模式**. 其中**外部模式**(增加, 更新和刷新)可以从文件系统中读取文件, 而**内部模式**(删除和复制)只会对zip文件内部进行操作.

* **add**
  * 更新已存在的文件和添加新的文件. 如果zip文件不存在会自动创建, 这是默认的模式.
* **update** (**-u**)
  * 更新已存在的文件和添加新的文件. 如果zip文件不存在则提示警告消息并创建文件.
* **freshen** (**-f**)
  * 如果文件系统中的文件更新, 则更新已存在的文件. 这个模式不会添加新的文件到zip文件中.
* **delete** (**-d**)
  * 获取zip文件中的文件并删除他们.
* **copy** (**-U**)
  * 获取一个zip文件中的文件并将他们复制到另一个新的zip文件中. 这个新的模式和\*\*`update`**模式很相似, 但这个模式是从一个已存在的zip文件中获取文件而不是从文件系统中获取. 它使用**`--out`\*\*选项将获取到的文件写入新的zip文件中并不会修改原来的zip文件.

新的文件同步选项\*\*`-FS`**也可以被认为是一个新的模式, 和**`update`\*\*类似. 这个模式对已存在于zip文件中的文件和文件系统中的文件进行比较, 如果文件时间和大小有不同的话, 会更新这个文件. 另外也可以新增不存在的文件, 删除已存在的文件.

### **切分zip文件**

3.0及以上版本的`zip`程序支持创建拆分文件. 一个切分的zip文件是由一个标准的zip文件切分成多份而成的.

切分文件的一个常用场景是将一个大的zip文件切分成多个小块, 并保存在多个移动设备中. 对于一个zip文件, 如果要把它拆分成20份, 那么这些文件的命名将会是`ARCHIVE.z01, ARCHIVE.z02, ..., ARCHIVE.z19, ARCHIVE.zip`(将ARCHIVE替换为zip文件的名称即可). 注意最后一个zip子文件的扩展名为`.zip`.

使用\*\*`-s`\*\*选项去设置切分文件的大小并创建一个拆分的zip文件. 切分文件的大小需要以一个数字和一个单位组成, 单位包括: k(KB), m(MB), g(GB), 或者t(TB), 其中默认为m. \*\*`-sp`**可以实现暂停`zip`程序并更换可移动设备. 具体的描述和警告消息和查看**`-s`**和**`-sp`\*\*选项的内容.

虽然`zip`不支持对拆分后文件内容的更新, 但是`zip`提供\*\*`-O (--output-file or --out)`\*\*选项允许对已拆分的文件更新并保存到一个新的zip文件中.

 `zip inarchive.zip foo.c bar.c --out outarchive.zip`

首先会读取`inarchive.zip`文件的内容, 即使它是已拆分的zip文件, 然后将`foo.c`和`bar.c`添加到结果zip文件(`outarchive.zip`)中. 如果`inarchive.zip`是一个已拆分的文件那么`outarchive.zip`默认情况下会使用相同的切分文件大小. 需要注意的是: 如果`outarchive.zip`或者其他需要被创建的拆分文件已存在的话, 将会对这些文件自动进行重写并不发出警告消息.

### **命令行格式**

当前版本的`zip`已经更新了命令行程序并且支持长选项.

短选项的格式如下:

 `-s[-][s[-]...][value][=value][ value]`

其中, `s`是指有一到两个字符的短选项. 一个带值的短选项会被放在参数的最后面, 这个选项后面的任何东西都会被视为这个选项的值. 如果这个选项可以被否定(执行相反的效果)那么在这个选项后面紧跟着的"-"可以对选项进行否定. 短选项可以被作为独立的参数给出:

 `-s[-][value][=value][ value] -s[-][value][=value][ value] ...`

一般情况下, 短选项可以将自己的值作为参数的一部分或者作为一个独立的参数. 并且短选项也支持"=", 所以

 `-ttmmddyyyy`

和

 `-tt=mmddyyyy`

和

 `-tt mmddyyyy`

都可以达到相同的效果. 但是\*\*`-x`**和**`-i`**选项支持接收多个值的集合, 它们的使用方法和上面的有些不同, 详细的使用方法可以参照对**`-x`**和**`-i`\*\*选项的介绍.

长选项的格式为:

 `--longoption[-][=value][ value]`

其中, 长选项以--开头, 并且长选项的名称包含多个字符, 它可以在结尾跟一个"-"表示对选项的否定(如果选项支持否定的话), 并且如果选项需要参数的话可以通过在选项后面跟=的方式实现, 也可以通过将值作为另外一个参数的方式实现. 所以

 `--before-date=mmddyyyy`

和

 `--before-date mmddyyyy`

具有相同的效果.

## 5. 选项

* \-a, --ascii
  * 将文件转为ASCII编码格式
* \-B, --binary
  * 将文件强制转为可读的二进制文件, 默认情况下文件是文本文件格式.
* \-b path, --temp-path path
  * 为临时创建的zip文件指定一个路径`path`. 例如:
    * `zip -b /tmp stuff *`
  * 将会把临时创建的zip文件放在`/tmp`路径下, 并且在操作完成后将`stuff.zip`复制到当前目录下. 当需要更新一个已存在的zip文件并且保存旧的zip文件的文件系统没有足够的空间可以同时保存新的和旧的zip文件时这个选项很有用. 需要注意的是使用这个选项会需要额外的时间使得zip可以将新打包的zip文件复制到目标文件系统下.
* \-c, --entry-comments
  * 为每个文件添加一行备注信息. 当文件操作(添加, 更新)完成后, 用户可以为每个文件添加备注信息. 使用回车键提交写入的备注信息即可.
* \-d, --delete
  * 从zip文件中移除内容, 例如:
    * `zip -d foo foo/tom/junk foo/harry/\* \*.o`
  * 将会移除`foo/tom/junk`, 所以以`foo/harry/`开头的文件, 和所有以\*\*`.o`\*\*(任何路径下)结尾的文件. 注意: 反斜杠`\`可以禁止zip继续向下扩展路径, 这样zip才可以识别星号`*`. 这使得zip可以去匹配zip文件中的内容而不是当前路径下的内容. 但是反斜杠`\`在MSDOS内核的系统下是不适用的, 我们可以使用引号来实现同样的效果.
    * `zip -d foo foo/tom/junk "foo/harry/*" "*.o"`
  * 如果不对星号`*`进行转义, 根据shell的扩展规则将会把星号`*`转为当前路径下的所有文件的集合, 之后zip会根据这个集合的文件名称去删除zip文件中的文件.
  * **注意**: 在MSDOS系统下, 当在匹配zip文件中的名称时, \*\*`-d`**是大小写敏感的. 如果zip文件是在MSDOS系统上使用`PKZIP`打包的话, 需要我们输入的待删除的文件是大写的格式. 但是使用新的选线**`-ic`\*\*可以忽略大小写问题.
* \-db, --display-bytes
  * 展示多少字节被压缩, 多少字节被保留.
* \-dc, --display-counts
  * 展示多少文件被压缩, 多少文件被跳过.
* \-dd, --display-dots
  * 在每个文件被压缩时展示一个点`.`符号. 在下面的\*\*`-ds`\*\*选项中设置点的大小. 默认情况下每10MB的输入内容被处理后会输出一个点. \*\*`-v`**也会展示点并且速度也是通过**`-ds`\*\*去控制的.
* \-dg, display-globaldots
  * 使用点`.`表示整个压缩的进程而不是代表每个文件的进度. 下面的命令:
    * `zip -qdgds 10m`
  * 会避免输出大部分的点而只在每进行完10MB进度后输出一个点`.`.
* \-ds size, --dot-size size
  * 设置在执行完多大的文件内容后输出一个点`.`. 通过\*\*`-dd`\*\*来启用展示点`.`符号. `size`的格式为nm, 其中n代表这一个数字, m表示单位. 单位包括: k(KB), m(MB), g(GB), 或者t(TB), 所以如果n是100并且m是k的话, size表示的是100KB. 默认值为10MB.
  * \*\*`-v`\*\*选项也可以输出点符号并且默认的文件大小也是10MB. 输出的速率也是通过相同的选项控制的. 如果`size`为0表示关闭点符号的输出.
  * 注意这个选项不能控制`zip`扫描文件时输出点的行为. 在扫描输入文件时输出点`.`符号的速度被固定在每隔2秒或者扫描完指定数量的文件后.(取决于那个花时间更长).
* \-du, --display-usize
  * 展示每个文件没有被压缩的大小.
* \-D, --no-dir--entries
  * 不为文件件在zip文件创建项目. 默认情况下, 文件夹对应的项目会被在zip文件中创建并且文件夹对应的属性可以被保存在zip文件中. 另外我们可以通过`ZIPOPT`环境变量来修改默认的选项. 例如在Unix环境下的shell中:
    * `ZIPOPT="-D"; export ZIPOPT`
  * (环境变量`ZIPOPT`可以被用来这是任何选项, 包括\*\*`-i`**和**`-x`**.) 选项**`-D`**是**`-x "*/"`\*\*的简写形式
* \-DF, --difference-archive
  * 创建一个新的zip文件只包含相对于上次创建的zip文件后新增或者更新的文件. 为了达到这个目的, 输入文件的集合与当前的目录必须与原始的zip文件一致才行.
  * 例如, 如果已存在的zip文件使用的是下面的命令:
    * `zip -r foofull .`
  * 为`bar`文件夹创建的, 那么命令:
    * `zip -r foofull . -DF --out foonew`
  * 将仍然为`bar`文件夹创建一个新的zip文件`foonew`, 并且这个新的zip文件中只包含那些不在`foofull`中的文件以及与`foofull`中的文件相比大小或者修改时间有变化的文件.
  * 注意: 关于时区的环境变量`TZ`应该被设置为当地的时区, 这样可以保证这个选项可以正确的工作. 如果在原zip文件之后修改了时区的话会造成修改时间无法匹配而导致所有的文件都会被包含在新的zip文件中.
  * 一个可行的备份文件夹的方式可以通过首先对文件夹生成一次完整的zip文件, 接下来使用这个选项去创建增量的备份.
* \-e, --encrypt
  * 使用一个密码对zip文件进行加密, 这个密码将通过命令行输入并对应着一个提示信息. 密码的提示用来帮助用户以防止密码输入错误.
* \-f, --freshen
  * 如果当前文件的修改时间比zip文件中的相同文件的修改时间更加新时, 将当前文件更新到zip文件中去. 这和update选项(**`-u`**)区别在于, update不会将已存在的文件添加到zip文件中. 例如:
    * `zip -f foo`
  * 这个命令需要和原来的zip文件在同一个文件夹中执行, 这样才能在相同的路径下去比较相同文件名的修改时间.
  * 注意: 关于时区的环境变量`TZ`应该被设置为当地的时区, 这样可以保证\*\*`-f, -u`**和**`-o`\*\*选项可以正确的工作.
* \-FS, --filesync
  * 将zip文件中的内容和系统中文件进行同步. 一般情况下, 当一个zip文件被更新时, 新增文件将会被添加并且修改过的文件将会被更新, 但是不在操作系统中的文件**不会**被从zip文件中删除. 这个选项启动一个新的模式, 在这个模式下将会对比zip文件和操作系统中的内容. 如果文件的更新时间和文件大小和系统中的文件相同时, 这个文件将会从原来的zip文件复制到新的zip文件中而不是从操作系统中读取并压缩. 如果系统中的文件已被修改, 则和正常情况一下读取压缩. 如果原来的zip文件中的内容在系统中找不到对应那么这个文件将**不会被添加**到新的zip文件中去. 如果要使用这个选项就必须让新的zip文件和原来的zip文件对同一个文件夹打包. 因为相同的文件是直接从原来的zip文件中复制, 所以使用\*\*`-FS`**更新zip文件会更加快一些. 另外**`-u`\*\*也可以实现更新zip文件.
  * 为了保证这个选项可以正确的执行, 必须保证原zip文件和新zip文件更新的是同一个文件夹.
  * 注意: 关于时区的环境变量`TZ`应该被设置为当地的时区, 这样可以保证该选项可以正确的工作.
  * 注意这个选项会删除zip文件中的内容, 所以如果你需要保留原始的zip文件的话, 请提前备份原始的zip文件或者使用\*\*`--out`\*\*选项将内容输出到一个新的zip文件中. 即便这样会慢一些, 但是创建一个新的zip文件名会更安全一些.
* \-g, --grow
  * 在指定的zip文件中添加新的文件而不是创建一个新的zip文件. 如果这个操作失败, `zip`将会尝试将zip文件恢复到原来的状态. 如果恢复失败, zip文件将会被损毁. 当指定的zip文件不存在或者有文件需要更新或者删除时将不会执行这个选项.
* \-h, -?, --help
  * 展示`zip`的帮助信息
* \-i files, --include files
  * 只对指定的文件进行打包. 比如:
    * `zip -r foo . -i \*.c`
  * 这个命令将只会打包当前文件夹和子文件夹中以`.c`结尾的文件. 其中, 反斜杠`\`避免了shell的文件名替换使得通过`zip`对当前目录下的所有文件进行比对名称.
  * 例如需要打包当前目录下的一个文件夹, 可以通过:
    * `zip -r foo . -i dir/\*` 或者 `zip -r foo . -i "dir/*"`
  * 这样可以匹配到dir路径下的所有文件, 例如: dir/a, dir/b/file.c. 需要注意的是对于文件夹结果的斜杠`/`是必须有的.
  * 在长选项的方式下, 我们可以使用下面的命令实现和第一个例子相同的结果:
    * `zip -r foo . --include \*.c`
  * 尽管`zip`的语法建议将\*\*`-i`**选项放在命令行的最后, 当时目前的`zip`版本已经支持将**`-i / --include`**放在任何地方. 想要终止**`-i`**的参数即包含的文件集可以通过在`zip`的下一个参数前面加上`-`符号的方式, 或者将文件集放在命令行的末尾, 又或者在文件集的最后加上**`@`\*\*符号. 所以上面的命令可以被写成下面的方式:
    * `zip -i \*.c @ -r foo .`
  * 在选项和文件集的第一个文件之间需要有一个空格, 但是如果文件集只包含一个文件的话, 也可以通过下面的方式:
    * `zip -i\*.c -r foo .`
  * (在选项和文件集之间不使用空格)或者
    * `zip --include=\*.c -r foo .`
  * 作为另一种实现的方式.
  * 但是这种文件集只存在单个文件的文件不建议被使用, 因为这样可以会造成歧义. 比如如果文件的首字母和**i**可以组成一个新的两个字母的选项, 那么\*\*`-ifile`**格式的写法可能会导致一些问题. 可以通过使用**`-sc`\*\*选项去查看命令行是如何解释你输入的命令的.
  * 下面的方式也可以实现相同的功能:
    * `zip -r foo . -i@include.lst`
  * 这个操作只会将能匹配到`include.lst`文件中模式的文件添加到zip文件中去.
* \-j, --junk-paths
  * 只将文件的名称保存到zip文件中, 而舍弃路径信息. 即不保存文件的文件夹名称. 默认情况下, `zip`会保存全路径.(相对于当前的路径)
* \-l, --to-crlf
  * 将Unix格式的换行符LF转为MSDOS格式的CR LF. 这个选项不应该在二进制文件上使用. 这个选项可以被用在Unix系统上并且zip文件将被MSDOS系统下的PKUNZIP程序使用.
* \-la, --log-append
  * 在已存在的日志文件后面追加日志. 模式情况下是覆盖原有的日志.
* \-lf logfilepath, --logfile-path logfilepath
  * 打开指定位置的日志文件. 默认情况下在指定路径下的任何已存在的文件否会被覆盖, 但是如果使用\*\*`-la`**选项程序就会打开这个已存在的文件并将新的日志信息追加到已有的日志后面. 默认情况下只有警告和错误信息才会被写入日志文件中, 除非使用**`-li`\*\*选项, 那么所有的信息都会被写入到日志文件中.
* \-li, --log-info
  * 将普通信息(例如被压缩的文件名称)也写入日志中. 默认情况下只会将命令行信息, 任何的警告和错误信息以及最终的执行状态写入到日志中.
* \-ll, --from-crlf
  * 将MSDOS格式的换行符CR LF转换为Unix格式的LF. 这个选项不应该在二进制文件上使用. 这个选项可以被用在MSDOS系统下并且生成的zip文件打算在Unix系统下的unzip使用.
* \-L, --license
  * 展示`zip`程序的证书信息.
* \-m, --move
  * 将指定文件移动到zip文件中去. 实际上, 在zip文件打包完成后会删除原来的文件或者文件夹. 如果一个文件夹中在删除这些文件之后变空, 那么这个文件夹也会被删除. 在压缩程序没有正确执行完成之前不会进行任何的删除操作.
  * 这个选项在节省磁盘空间时非常有空, 但是它存在潜在的风险, 所以建议联合\*\*`-T`\*\*选项先执行测试之后在删除指定的文件.
* \-MM, --must-match
  * 所有的关于输入文件的正则表达式至少匹配到一个文件, 并且所有匹配到的文件必须可读. 一般情况下, 如果一个关于输入文件的正则表达式没有匹配到任何文件时, 程序会提示一个"name not matched"警告. 如果当需要打包的文件刚开始被找到但是后来不见了或者这个文件不可读, 一个文件丢失或者文件不可读的警告会被程序发出. 在其他情况下, `zip`会继续创建zip文件, 丢失的文件或者不可读的文件会被掉过, 已存在于zip文件中的文件将不会被改动. 在zip文件创建完成之后, 如果存在任何的不可读文件`zip`会返回一个开放的错误状态码(大多数操作系统中是18)而不是程序正常返回的状态码(大多数操作系统中是0). 如果使用了\*\*`-MM`\*\*参数, 只要出现没有匹配到文件的正则表达式或者任何不可读的文件, `zip`会直接退出.
* \-n suffixes, --suffixes suffixes
  * 不对指定的后缀名称的文件进行压缩, 这些后缀的文件将只是被保存到zip文件中. 这样`zip`程序不会在压缩这些文件上浪费时间. 这些后缀的集合可以使用分号`;`或者冒号`:`进行分隔. 例如:
    * `zip -rn .Z:.zip:.tiff:.gif:.snd foo foo`
  * 将会把foo目录下的所有文件复制到foo.zip中, 但是只会对以`.Z, .zip, .tiff, .gif, .snd`结尾的文件进行保存而不去压缩. 默认情况下, `zip`不会对以`.Z:.zip:.zoo:.arc:.lzh:.arj`结尾的文件进行压缩. 这些文件将直接被保存到输出的zip文件中去. 使用环境变量`ZIPOPT`可以修改这一特性的默认值. 例如在Unix环境下可以通过:
    * `setenv ZIPOPT "-n .gif:.zip"`
  * 如果需要对所有的输入文件都进行压缩, 可以通过:
    * `zip -n : foo`
  * 最大效力的压缩选项\*\*`-9`\*\*可会尝试对所有的文件进行压缩, 而不去查看文件的后缀.
* \-nw, --no-wild
  * 不执行内部通配符处理(shell的通配符处理仍然会被shell执行, 除非对参数进行转义).
* \-o, --latest-time
  * 将zip文件的最后修改时间设置为zip文件中的所有项目的最后修改时间最旧的那个值. 这个选项可以不搭配任何其他的选项使用, 比如:
    * `zip -o foo`
  * 将会修改foo.zip文件的最后修改时间为foo.zip中包含的所有文件最后修改时间最旧的那个值.
* \-O output-file, --output-file output-file
  * 对于不是更新的操作, 和其他的选项执行方式一致. 如果是对已有zip文件更新的话, 输出一个新的zip文件到指定的`output-file`文件位置. 在需要更新原有的zip文件并且不想修改原有文件时非常有用.
  * 这个选项可用来更新原zip文件为多个分割的zip文件. 该选项也可以和\*\*`-U`\*\*选项搭配使用从原有的zip文件中复制项目到新的zip文件中去.
  * 另一个用法为: 将原zip分割文件的大小修改成其他的大小. 例如将700MB CD大小的zip分割文件转为2GB DVD大小的文件.
    * `zip -s 2g cd-split.zip --out dvd-split.zip`
  * 上面的命令使用的是`copy`模式. 另外, 使用下面的命令可以将切割的zip文件合为一个完整的zip文件:
    * `zip -s 0 split.zip --out unsplit.zip`
* \-p, --paths
  * 将相对路径也作为文件名称的一部分保存到zip文件中. 这是默认的模式. 使用\*\*`-j`\*\*选项可以略过路径信息只保存文件的名称.
* \-P password, --password password
  * 使用`password`对文件进行加密. **这个操作不能保证安全!** 许多的多用户操作系统提供方法可以让其他的用户看到当前用户命令行的内容. 如果可以, 建议使用交互式并且不会返回输入内容的方式输入密码.
* \-q, --quiet
  * 静默模式. 限制普通信息和备注提示的输出. (在后台任务执行时非常有用.)
* \-r, --recurse-paths
  * 递归遍历目录结果, 例如:
    * `zip -r foo.zip foo` 或 `zip -r foo foo`
  * 在这个例子中, `foo`目录下的所有文件和文件夹都会保存到一个叫做`foo.zip`的zip文件中, 包括以\*\*"."**开头的文件, 因为递归不会使用shell的文件名替换机制. 如果你只想将`foo`目录下指定的子文件集添加到zip文件中, 可以通过**`-i`**选项实现. 注意不要将**`-r`**和**".\*"**一起使用, 因为这种情况下zip也会匹配到**".."\*\*, zip会尝试将当前路径的父路径也打包到zip文件中.
  * 可以将多个源文件夹添加到zip文件中:
    * `zip -r foo foo1 foo2`
  * 这里会先打包`foo1`然后打包`foo2`. 并递归打包每个文件夹下的内容.
* \-R, --recurse-patterns
  * 从当前的目录开始递归遍历文件夹, 例如:
    * `zip -R foo "*.c"`
  * 在这个例子中, 从当前目录开始, 所有的符合\*\*`*.c`**的文件都会被保存到一个名为`foo.zip`的zip文件中去. 注意**`*.c`**可以匹配到**`file.c, a/file.c, a/b/.c`\*\*文件. 可以列出多个正则表达式作为zip的参数.
  * 这里的正则表达式是基于相对路径的, 因为他们出现在zip文件中. 并且他们可以包含可选的通配符. 例如: 给定一个文件夹\*\*`foo`**, 它的下面有文件夹**`foo1, foo2`**, 并且**`foo1`**中包含文件**`bar.c`\*\*.
    * `zip -R foo/*`
  * 这里将会压缩\*\*`foo, foo/foo1, foo/foo1/bar.c, foo/foo2`\*\*/
    * `zip -R */bar.c`
  * 将会压缩\*\*`foo/foo1/bar.c`\*\*.
* \-s splitsize, --split-size splitsize
  * 创建一个拆分zip文件, 并且设置拆分文件的大小为`splitsize`. zip的拆分文件是将一个大的zip文件拆分成多个小的文件. 当在创建拆分的zip文件时, 如果当前zip文件的大小已经达到了指定的大小, 那么结束对当前zip文件输入内容并创建下一个新的分片. 一般情况下除了最后一个zip拆分文件外, 其余的文件都是`splitsize`大小. 如果完整的zip文件的大小小于`splitsize`的大小, 那么不会对文件进行拆分.
  * zip拆分文件使用数字的方式保存. 例如, 如果输出的zip文件名为\*\*`archive`**并且有个三个拆分文件的话, 那么zip拆分文件的名称将会是**`archive.z01, archive.z02, zrchive.zip`\*\*. 不要去修改这些文件的数字, 否则会导致这个zip文件不可读, 因为这些数字决定了zip文件的读取顺序.
  * 拆分文件的大小是一个数字加上单位. 目前这个数字必须是一个整数, 单位可以是\*\*`k(KB), m(MB), g(GB), t(TB)`**中的一个. `64k`是一个最小的拆分文件大小, 如果在数字后面没有写单位的话, 默认为m. 例如为**`bar`**文件夹创建一个拆分的zip文件**`foo`\*\*, 并且拆分文件大小670MB, 这样在烧制CD时非常有用. 可以通过:
    * `zip -s 670m -r foo bar`
  * 目前默认情况下, 一个拆分的zip文件中原有的子文件是不会从新的拆分文件中排除的, 但是可以强制指定排除它. 如果可以的话, 尽可能的保证输入和输出的zip文件和需要打包的文件不在需要打包的路径下.
  * 拆分的zip文件不可以白更新, 但是可以通过\*\*`-O(--out)`\*\*选项来实现更新更新的操作通过创建一个新的拆分zip文件的方式. 拆分的zip文件可以被合成一个完成的zip文件, 通过将拆分大小设置为0或者负数的方式. 例如:
    * `zip -s 0 split.zip --out single.zip中`
* \-sf, --show-files
  * 显示正在被zip程序处理中文件名称. 如果是创建一个新的zip文件, 这将会列出所有会被添加到zip文件中的文件名称. 如果这个选项被否定, **`-sf-`**, 输出的内容将只会被显示在日志文件中. 如果是大的文件列表不推荐在屏幕上展示这些信息.
* \-t mmddyyyy, --from-date mmddyyyy
  * 不要对修改日期在指定时间之前的文件进行操作. 其中, \*\*`mm`\*\*是指月份(00-12), \*\*`dd`\*\*是指月份中的天(01-31), \*\*`yyyy`\*\*是指年份.
  * `ISO 8601`格式的\*\*`yyyy-mm-dd`\*\*格式的日期也可以接受. 例如:
    * `zip -rt 12071001 infamy foo`
    * `zip -rt 1991-12-07 infamy foo`
  * 都可以实现将\*\*`foo`**和其所有子文件夹中的最后修改时期在1991年12月7号之后的文件添加到zip文件**`infamy.zip`\*\*中去.
* \-tt mmddyyyy, --before-date mmddyyyy
  * 不对修改时间在指定日期或者超过指定日期的文件进行操作. 其中, \*\*`mm`\*\*是指月份(00-12), \*\*`dd`\*\*是指月份中的天(01-31), \*\*`yyyy`\*\*是指年份.
    * `zip -rtt 11301995 infamy foo`
    * `zip -rtt 1995-11-30 infamy foo`
  * 将会对\*\*`foo`**和其所有子文件夹下的所有修改时间在1995年11月30日之前的文件进行打包, 把他们打包到**`infamy.zip`\*\*文件中去.
* \-U, --copy-entries
  * 从一个zip文件中复制内容到另外一个zip文件中. 需要使用\*\*`--out`**选项来指定一个不同于原zip文件名的新zip文件. 复制模式是**`-d`**删除模式的相反操作. 如果在删除时使用了**`--out`**选项, 被选中的内容会被从zip文件中删除, 剩下的所有内容会被复制到新的zip文件中去. 与此相对的是复制模式会将选中的内容复制到新zip文件中去. 和**`-u`\*\*更新操作不同的是, 命令行上输入的正则表达式只会去匹配指定的zip文件中的内容, 而不会匹配文件系统中的文件. 例如:
    * `zip inarchive "*.c" --copy --out outarchive`
  * 将**inarchive**中以\*\*.c**结尾的文件复制到**outarchive\*\*中去. 在一些操作系统中这些通配符需要被转义, 以防止shell程序使用文件系统中的文件名称替换通配符, 这会导致没法关联到zip文件中的文件.
  * 如果没有指定需要复制的文件名称, 并且指定了输出的zip文件名, 例如:
    * `zip inarchive --out outarchive`
  * 这种操作在将拆分zip文件包整合为一个完整的大文件包时非常有用. 复制模式不止吃对zip文件内容的加密和解密操作.
* \-v, --verbose
  * 详细模式或者是显示诊断信息.
  * 一般情况下, 如果在一个实际的压缩操作过程中使用这个选项, 这个选项会启动对于压缩进度的展示并且获取详细的关于zip文件结构的诊断信息.
  * 然而, 如果\*\*`-v`\*\*选项是程序的唯一一个选项的话, 将会展示详细的诊断信息. 即使是标准输出已经被重定向到一个文件中这些信息任然会被显示出来, 允许人们更加方便的将信息保存下来发送给报告bug的网站. 这些诊断信息包括: 程序名称, 版本号, 发布日期, 关于Info-ZIP的地址, 当前环境的一些信息.
* \-x files, --exclude files
  * 指定需要排除的文件名称. 例如:
    * `zip -r foo foo -x \*.o`
  * 这个命令会将**foo**路径下所有不以\*\*.o**结尾的文件打包到**foo.zip**文件中去. 其中, 反斜杠**`\`\*\*避免了shell的文件名替换, 使得文件名匹配是通过`zip`程序执行的.
  * 当然也可以使用:
    * `zip -r foo foo -x@exclude.lst`
  * 这个命令会将所有符合**exclude.lst**文件中正则表达式可以匹配到的文件排除之后, 将**foo**目录下剩余的文件打包到**foo.zip**中.
  * 上面命令的长选项格式为:
    * `zip -r foo foo --exclude \*.o` 和 `zip -r foo foo --exclude @exclude.lst`
  * 可以指定多个匹配表达式, 例如:
    * `zip -r foo foo -x \*.o \*.c`
  * 如果只指定一个参数的话, 在\*\*-x\*\*和匹配表达式之间可以没有空格. 如
    * `zip -r foo foo -x\*.o`
* \-X, --no-extra
  * 不要保存额外的文件属性(在OS/2上面的扩展属性, Unix上的uid/gid和文件时间). `zip`程序使用额外的字段去保存每个文件附加信息. 其中一些额外字段是在某一些操作系统中有用, 而其他的在所有的操作系统中都可以使用. 一般情况下, 当`zip`从zip文件中读取内容时, 它会将自己知道的额外字段也读取到, 并将这些信息添加到当前系统的对应文件属性中去. 如果使用\*\*-X\*\*, `zip`会舍弃掉所有的旧字段只保留Unicode和Zip64的额外字段.
  * 否定这个选项, **-X-**, 将会包含所有的默认额外字段并且复制任何程序没有识别的额外属性.
* \-z, --archive-comment
  * 为zip文件补充多行注释. 注释使用一个只包含句点`.`的行作为终止符或者操作系统的文件终止符(Unix上的^D, MSDOS, OS/2上的^Z). 也可以通过文件的方式输入注释内容:
    * `zip -z foo < foowhat`
* \-Z cm, --compression-method cm
  * 设置一个默认的压缩方法. 目前`zip`支持的

\#常用选项 -m #压缩完成有删除源文件 -r #需要压缩的是一个目录 -j #忽略子目录内容 -n 文件 #选择不需要压缩的文件(忽略他们) -y #不要压缩链接文件的源文件 -数字 #设置压缩率(1-9,9为最高压缩率)

\#注意 1.zip与gz的区别 zip在处理文本文件处理方面优越 gz在处理二进制文件处理方面优越 2.-n选项的后面如果有多种格式,将每种格式之间使用:分隔

\#示例 #zip后面接压缩后的文件名，在它后面输入要压缩的文件 zip file.zip \* zip file.zip aaa bbb ccc #将多个文件压缩到同一包中 #将a.txt压缩为file.zip文件并在压缩完成后删除源文件 zip -m file.zip a.txt zip -r file.zip \* #将当前目录下的子目录一起压缩 zip -j file.zip \* #忽略子目录的内容 zip -n .jpg: .gif:.mpg #将以压缩的文件或者没必要压缩的文件去掉 zip -y file.zip \* #不要压缩链接文件的原文件 zip -3 file.zip \* #按照3的压缩率压缩指定文件

***

\#解压缩文件夹 格式:unzip 压缩包

\#常用选项 -Z #显示压缩包内容 -l #同上 -v #同上

\#示例 unzip file.zip #解压目标文件 unzip -Z file.zip unzip -l file.zip unzip -v file.zip
